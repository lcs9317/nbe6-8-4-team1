name: PR → Auto-link or Auto-create Issue (manual-safe, project-ensure, no loops)

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  PROJECT_OWNER: lcs9317
  PROJECT_NUMBER: 3

concurrency:
  group: pr-auto-issue-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  ensure-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Link or create issue (manual-first, ensure project, no loops)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}  # PAT(Projects write + read:org 권장)
          script: |
            const pr    = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const stripForScan = (s) =>
              (s || "")
                .replace(/<!--[\s\S]*?-->/g, "")
                .replace(/```[\s\S]*?```/g, "")
                .replace(/`[^`]*`/g, "");
            
            const scanBody = stripForScan(pr.body || "");
            const hasManualClose = /\b(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\b\s*[:\-–]?\s*#\d+\b/i.test(scanBody);
            
            if (hasManualClose) {
              core.info("Manual close reference detected → skip auto-issue creation/update.");
              return;
            }
            // ---------------- helpers ----------------
            const closeRe     = /\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\s+#(\d+)\b/i;
            const prMarkerRe  = /<!--\s*auto-linked-issue:(\d+)\s*-->/;

            const normalize = (s) =>
              (s || "")
                .replace(/\r\n/g, "\n")
                .replace(/[ \t]+$/gm, "")  // trim only end-of-line spaces
                .replace(/\n+$/,"");       // drop trailing blank lines

            // 덧붙이기 방식: 기존 본문 보존, 필요한 줄만 추가 → 루프 방지
            const appendCloseAndMarkerIfNeeded = (body, n) => {
              let out = body || "";
              const hasCloseForN = new RegExp(`\\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\\s+#${n}\\b`, 'i').test(out);
              const hasMarker    = prMarkerRe.test(out);
              if (!hasCloseForN) out += `\n\nCloses #${n}`;
              if (!hasMarker)    out += `\n<!-- auto-linked-issue:${n} -->`;
              return out;
            };

            const ensureLabels = async (names) => {
              for (const name of names) {
                try { await github.rest.issues.getLabel({ owner, repo, name }); }
                catch { await github.rest.issues.createLabel({ owner, repo, name, color: "ededed" }); }
              }
            };

            // [TYPE]: 제목 → TYPE/Subject
            const typeMatch = (pr.title || "").match(/^\s*\[(FEAT|FIX|REFACTOR|COMMENT|STYLE|TEST|CHORE|INIT)\]\s*:\s*/i);
            const TYPE     = (typeMatch ? typeMatch[1] : "CHORE").toUpperCase();
            const SUBJECT  = (pr.title || "").replace(/^\s*\[[^\]]+\]\s*:\s*/,'').trim() || `PR #${pr.number}`;
            const FULLTITLE = pr.title || "";

            // ---------------- 0) 먼저 Close로 판정 ----------------
            let issueNumber = null;
            let mode = null; // 'manual' | 'auto-existing' | 'auto-created'

            const body0 = pr.body || "";
            const mClose = body0.match(closeRe);
            if (mClose) {
              const n = Number(mClose[1]);
              try {
                await github.rest.issues.get({ owner, repo, issue_number: n });
                issueNumber = n;
                mode = 'manual';
              } catch {}
            }

            // ------------- 1) 제목 완전일치 이슈 (수동) -------------
            if (!issueNumber) {
              const q = `repo:${owner}/${repo} is:issue is:open in:title "${FULLTITLE.replace(/"/g,'\\"')}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q });
              if (res.data.items.length === 1) {
                issueNumber = res.data.items[0].number;
                mode = 'manual';
              }
            }

            // ------ 2) 이전 자동 생성된 이슈(이 PR용 마커) ------
            if (!issueNumber) {
              const q = `repo:${owner}/${repo} is:issue is:open in:body "auto-issue-for-pr:${pr.number}" label:auto`;
              const r = await github.rest.search.issuesAndPullRequests({ q });
              if (r.data.items.length > 0) {
                issueNumber = r.data.items[0].number;
                mode = 'auto-existing';
              }
            }

            // ---------------- 3) 없으면 자동 생성 ----------------
            let createdNew = false;
            if (!issueNumber) {
              mode = 'auto-created';
              await ensureLabels(["auto", "needs-triage", TYPE]);

              const issueTitle = `[${TYPE}]: ${SUBJECT}`;
              const issueBody = [
                `### 변경 유형 (Type)`,
                TYPE,
                ``,
                `### 제목(Subject)`,
                SUBJECT,
                ``,
                `---`,
                `Auto-created for PR #${pr.number}`,
                `<!-- auto-issue-for-pr:${pr.number} -->`
              ].join("\n");

              const created = await github.rest.issues.create({
                owner, repo, title: issueTitle, body: issueBody, labels: ["auto", "needs-triage", TYPE]
              });
              issueNumber = created.data.number;
              createdNew = true;
            }

            // -------- 4) PR 본문만 보정(필요시), 루프 방지 --------
            let desiredBody = appendCloseAndMarkerIfNeeded(body0, issueNumber);
            if (normalize(desiredBody) !== normalize(body0)) {
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body: desiredBody });
            }

            // ------------- 5) 수동 이슈는 절대 수정 금지 -------------
            if (mode === 'manual') {
              // 이슈 제목/본문/라벨/어사이니 등 "모두" 건드리지 않음
            } else {
              // 자동 케이스에서만(원래 동작 유지): 어사이니 등 세팅 가능
              try {
                const author = pr?.user?.login;
                if (author) {
                  try { await github.rest.issues.addAssignees({ owner, repo, issue_number: issueNumber, assignees: [author] }); } catch {}
                }
              } catch {}
            }

            // -------- 6) Projects(v2): 수동/자동 모두 보장 --------
            //    - 수동이어도 "이미 있으면 두고, 없으면 추가"
            //    - 이슈 내용은 건드리지 않음. 프로젝트 아이템만 관리.
            try {
              const login  = process.env.PROJECT_OWNER || context.repo.owner;
              const number = Number(process.env.PROJECT_NUMBER || 1);

              // 6-1) Project ID
              let projectId = null;
              try {
                const r = await github.graphql(
                  `query($login:String!,$number:Int!){
                    organization(login:$login){ projectV2(number:$number){ id } }
                  }`, { login, number }
                );
                projectId = r?.organization?.projectV2?.id || null;
              } catch {}
              if (!projectId) {
                try {
                  const r2 = await github.graphql(
                    `query($login:String!,$number:Int!){
                      user(login:$login){ projectV2(number:$number){ id } }
                    }`, { login, number }
                  );
                  projectId = r2?.user?.projectV2?.id || null;
                } catch {}
              }
              if (!projectId) return;

              // 6-2) Node IDs
              const [iss, prr] = await Promise.all([
                github.rest.issues.get({ owner, repo, issue_number: issueNumber }),
                github.rest.pulls.get({ owner, repo, pull_number: pr.number })
              ]);
              const issueNodeId = iss.data.node_id;
              const prNodeId    = prr.data.node_id;

              // 6-3) addIfMissing
              const listQ = `
                query($projectId:ID!, $after:String) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      items(first:50, after:$after) {
                        pageInfo { hasNextPage endCursor }
                        nodes { id content { ... on Issue { id } ... on PullRequest { id } } }
                      }
                    }
                  }
                }`;
              const addM = `
                mutation($projectId:ID!, $contentId:ID!) {
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }`;
              const addIfMissing = async (contentId) => {
                let cursor = null, found = null;
                while (true) {
                  const r = await github.graphql(listQ, { projectId, after: cursor });
                  const items = r?.node?.items?.nodes || [];
                  for (const it of items) if (it?.content?.id === contentId) { found = it.id; break; }
                  if (found || !r?.node?.items?.pageInfo?.hasNextPage) break;
                  cursor = r.node.items.pageInfo.endCursor;
                }
                if (found) return found;
                const a = await github.graphql(addM, { projectId, contentId });
                return a?.addProjectV2ItemById?.item?.id || null;
              };

              const issueItemId = await addIfMissing(issueNodeId);
              const prItemId    = await addIfMissing(prNodeId);

              // 6-4) Status (프로젝트 필드만; 이슈 내용 X)
              const desiredStatus = pr.draft ? "Ready" : "In progress";
              const fieldsQ = `
                query($projectId:ID!) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      fields(first:50) {
                        nodes {
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`;
              const fr = await github.graphql(fieldsQ, { projectId });
              const fields = fr?.node?.fields?.nodes || [];
              const statusField = fields.find(f => f.name === "Status" && f.options);
              if (statusField) {
                const opt = statusField.options.find(o => o.name === desiredStatus);
                if (opt) {
                  const setM = `
                    mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optId:String!) {
                      updateProjectV2ItemFieldValue(input:{
                        projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                        value:{ singleSelectOptionId:$optId }
                      }) { projectV2Item { id } }
                    }`;
                  if (issueItemId) await github.graphql(setM, { projectId, itemId: issueItemId, fieldId: statusField.id, optId: opt.id });
                  if (prItemId)    await github.graphql(setM, { projectId, itemId: prItemId,    fieldId: statusField.id, optId: opt.id });
                }
              }

              // 6-5) Start date: "비어 있을 때만" 세팅 (프로젝트 필드만)
              const startFieldName = "Start date";
              const startDate = (pr.created_at || new Date().toISOString()).substring(0,10);

              const getDateFieldValue = async (itemId, fieldName) => {
                if (!itemId) return null;
                const q = `
                  query($itemId:ID!) {
                    node(id:$itemId) {
                      ... on ProjectV2Item {
                        fieldValues(first:50) {
                          nodes {
                            ... on ProjectV2ItemFieldDateValue {
                              date
                              field { ... on ProjectV2FieldCommon { id name } }
                            }
                          }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { itemId });
                const nodes = r?.node?.fieldValues?.nodes || [];
                const hit = nodes.find(n => n?.field?.name === fieldName);
                return hit?.date || null;
              };

              const setStartIfEmpty = async (itemId) => {
                if (!itemId) return;
                const existing = await getDateFieldValue(itemId, startFieldName);
                if (existing) return; // 이미 있으면 손대지 않음

                const fieldsQ2 = `
                  query($projectId:ID!) {
                    node(id:$projectId) {
                      ... on ProjectV2 {
                        fields(first:50) { nodes { ... on ProjectV2FieldCommon { id name dataType } } }
                      }
                    }
                  }`;
                const fr2 = await github.graphql(fieldsQ2, { projectId });
                const fields2 = fr2?.node?.fields?.nodes || [];
                const startFieldId = fields2.find(f => f.name === startFieldName && f.dataType === "DATE")?.id;
                if (!startFieldId) return;

                const mut = `
                  mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $d:Date!) {
                    updateProjectV2ItemFieldValue(input:{
                      projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                      value:{ date:$d }
                    }) { projectV2Item { id } }
                  }`;
                await github.graphql(mut, { projectId, itemId, fieldId: startFieldId, d: startDate });
              };

              await setStartIfEmpty(issueItemId);
              await setStartIfEmpty(prItemId);
            } catch {}
