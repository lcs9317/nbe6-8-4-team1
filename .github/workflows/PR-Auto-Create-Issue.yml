name: PR → Auto-link or Auto-create Issue (manual-safe, project-ensure, no loops)

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  PROJECT_OWNER: lcs9317          # org/user 로그인 (프로젝트 주인)
  PROJECT_NUMBER: 3               # Project(v2) 번호

concurrency:
  group: pr-auto-issue-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  ensure-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Link or create issue (manual-first, ensure project, no loops)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}  # PAT(Projects write + read:org 권장)
          script: |
            const pr    = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // ---------------- helpers ----------------
            const normalize = (s) =>
              (s || "")
                .replace(/\r\n/g, "\n")
                .replace(/[ \t]+$/gm, "")
                .replace(/\n+$/, "");

            // 코드블록/인라인코드만 제거 (HTML 주석은 유지 → 마커 읽기 위함)
            const stripForScan = (s) =>
              (s || "")
                .replace(/```[\s\S]*?```/g, "")
                .replace(/`[^`]*`/g, "");

            const ensureLabels = async (names) => {
              for (const name of names) {
                try { await github.rest.issues.getLabel({ owner, repo, name }); }
                catch { await github.rest.issues.createLabel({ owner, repo, name, color: "ededed" }); }
              }
            };

            // 수동/자동 구분과 무관하게 "대상 n"만 보고 보정
            const appendCloseAndMarkerIfNeeded = (body, n) => {
              let out = body || "";
              const hasCloseForN  = new RegExp(`\\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\\b\\s*[:\\-–]?\\s*#${n}\\b`, 'i').test(out);
              const hasMarkerForN = new RegExp(`<!--\\s*auto-linked-issue:${n}\\s*-->`).test(out);
              if (!hasCloseForN)  out += `\n\nCloses #${n}`;
              if (!hasMarkerForN) out += `\n<!-- auto-linked-issue:${n} -->`;
              return out;
            };

            // ---------------- 제목/타입 파싱 ----------------
            const typeMatch = (pr.title || "").match(/^\s*\[(FEAT|FIX|REFACTOR|COMMENT|STYLE|TEST|CHORE|INIT)\]\s*:\s*/i);
            const TYPE     = (typeMatch ? typeMatch[1] : "CHORE").toUpperCase();
            const SUBJECT  = (pr.title || "").replace(/^\s*\[[^\]]+\]\s*:\s*/,'').trim() || `PR #${pr.number}`;
            const FULLTITLE = pr.title || "";

            // ---------------- 본문 검사 (수동 close 오인 방지) ----------------
            const rawBody  = pr.body || "";
            const scanBody = stripForScan(rawBody);

            // 우리 액션이 남긴 마커로 "자동 관리 이슈 번호들" 수집
            const autoLinkedNums = [...rawBody.matchAll(/<!--\s*auto-linked-issue:(\d+)\s*-->/g)]
              .map(m => Number(m[1]));

            // 본문에 존재하는 close/fix/resolve 참조의 이슈 번호들 수집
            const closeRefRe = /\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\b\s*[:\-–]?\s*#(\d+)\b/ig;
            const closeRefs = [...scanBody.matchAll(closeRefRe)].map(m => Number(m[1]));

            // "수동 close" 판단: 마커에 없는 번호가 하나라도 있으면 수동
            const manualCloseNumbers = closeRefs.filter(n => !autoLinkedNums.includes(n));
            const hasManualClose = manualCloseNumbers.length > 0;

            if (hasManualClose) {
              core.info(`Manual close reference detected (not auto-managed): ${JSON.stringify(manualCloseNumbers)}`);
            } else if (closeRefs.length > 0) {
              core.info(`Only auto-managed close refs detected: ${JSON.stringify(closeRefs)}`);
            } else {
              core.info("No close refs detected.");
            }

            // ---------------- 이슈 선택/생성 ----------------
            let issueNumber = null;
            let mode = null; // 'manual' | 'auto-existing' | 'auto-created'

            // 0) 수동 close가 있으면 해당 번호(첫 번째)를 우선 시도
            if (hasManualClose) {
              const n = manualCloseNumbers[0];
              try {
                await github.rest.issues.get({ owner, repo, issue_number: n });
                issueNumber = n;
                mode = 'manual';
              } catch {}
            }

            // 1) 제목 완전일치 오픈 이슈(수동 연결 가정)
            if (!issueNumber) {
              const q = `repo:${owner}/${repo} is:issue is:open in:title "${FULLTITLE.replace(/"/g,'\\"')}"`;
              const res = await github.request('GET /search/issues', {
                q, per_page: 1, advanced_search: true,
                headers: { 'X-GitHub-Api-Version': '2022-11-28' }
              });
              if (res.data.items.length === 1) {
                issueNumber = res.data.items[0].number;
                mode = 'manual';
              }
            }

            // 2) 이전 자동 생성된 이슈 (마커 + label:auto)
            if (!issueNumber) {
              const q = `repo:${owner}/${repo} is:issue is:open in:body "auto-issue-for-pr:${pr.number}" label:auto`;
              const r = await github.request('GET /search/issues', {
                q, per_page: 1, advanced_search: true,
                headers: { 'X-GitHub-Api-Version': '2022-11-28' }
              });
              if (r.data.items.length > 0) {
                issueNumber = r.data.items[0].number;
                mode = 'auto-existing';
              }
            }

            // 3) 없으면 자동 생성 (수동 close 있으면 생성하지 않음)
            if (!issueNumber && !hasManualClose) {
              mode = 'auto-created';
              await ensureLabels(["auto", "needs-triage", TYPE]);

              const issueTitle = `[${TYPE}]: ${SUBJECT}`;
              const issueBody = [
                `### 변경 유형 (Type)`,
                TYPE,
                ``,
                `### 제목(Subject)`,
                SUBJECT,
                ``,
                `---`,
                `Auto-created for PR #${pr.number}`,
                `<!-- auto-issue-for-pr:${pr.number} -->`
              ].join("\n");

              const created = await github.rest.issues.create({
                owner, repo, title: issueTitle, body: issueBody, labels: ["auto", "needs-triage", TYPE]
              });
              issueNumber = created.data.number;
            }

            // 4) PR 본문 보정(필요 시), 루프 방지
            if (issueNumber) {
              const body0 = pr.body || "";
              const desiredBody = appendCloseAndMarkerIfNeeded(body0, issueNumber);
              if (normalize(desiredBody) !== normalize(body0)) {
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body: desiredBody });
              }
            } else {
              core.info("No issue determined for this PR → skipping issue creation/update only.");
            }

            // 5) 수동 이슈는 이슈 내용/라벨/어사이니 수정 안 함
            if (mode && mode.startsWith('auto')) {
              try {
                const author = pr?.user?.login;
                if (author && issueNumber) {
                  try { await github.rest.issues.addAssignees({ owner, repo, issue_number: issueNumber, assignees: [author] }); } catch {}
                }
              } catch {}
            }

            // ---------------- Projects(v2) 보장 + Status/Start date ----------------
            try {
              const login  = process.env.PROJECT_OWNER || context.repo.owner;
              const number = Number(process.env.PROJECT_NUMBER || 1);

              // Project ID (org → user 순)
              let projectId = null;
              try {
                const r = await github.graphql(
                  `query($login:String!,$number:Int!){
                    organization(login:$login){ projectV2(number:$number){ id } }
                  }`, { login, number }
                );
                projectId = r?.organization?.projectV2?.id || null;
              } catch {}
              if (!projectId) {
                try {
                  const r2 = await github.graphql(
                    `query($login:String!,$number:Int!){
                      user(login:$login){ projectV2(number:$number){ id } }
                    }`, { login, number }
                  );
                  projectId = r2?.user?.projectV2?.id || null;
                } catch {}
              }
              if (!projectId) { core.info("Project not found. Skipping project linking."); return; }

              // Node IDs
              const prResp = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
              const prNodeId = prResp.data.node_id;
              let issueNodeId = null;
              if (issueNumber) {
                const iss = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                issueNodeId = iss.data.node_id;
              }

              // 프로젝트 아이템에 없으면 추가
              const listQ = `
                query($projectId:ID!, $after:String) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      items(first:50, after:$after) {
                        pageInfo { hasNextPage endCursor }
                        nodes { id content { ... on Issue { id } ... on PullRequest { id } } }
                      }
                    }
                  }
                }`;
              const addM = `
                mutation($projectId:ID!, $contentId:ID!) {
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }`;
              const addIfMissing = async (contentId) => {
                if (!contentId) return null;
                let cursor = null, found = null;
                while (true) {
                  const r = await github.graphql(listQ, { projectId, after: cursor });
                  const items = r?.node?.items?.nodes || [];
                  for (const it of items) if (it?.content?.id === contentId) { found = it.id; break; }
                  if (found || !r?.node?.items?.pageInfo?.hasNextPage) break;
                  cursor = r.node.items.pageInfo.endCursor;
                }
                if (found) return found;
                const a = await github.graphql(addM, { projectId, contentId });
                return a?.addProjectV2ItemById?.item?.id || null;
              };

              const prItemId    = await addIfMissing(prNodeId);
              const issueItemId = await addIfMissing(issueNodeId);

              // Status 필드 ("Ready"/"In progress")
              const desiredStatus = pr.draft ? "Ready" : "In progress";
              const fieldsQ = `
                query($projectId:ID!) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      fields(first:50) {
                        nodes {
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`;
              const fr = await github.graphql(fieldsQ, { projectId });
              const fields = fr?.node?.fields?.nodes || [];
              const statusField = fields.find(f => f.name === "Status" && f.options);
              if (statusField) {
                const opt = statusField.options.find(o => o.name === desiredStatus);
                if (opt) {
                  const setM = `
                    mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optId:String!) {
                      updateProjectV2ItemFieldValue(input:{
                        projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                        value:{ singleSelectOptionId:$optId }
                      }) { projectV2Item { id } }
                    }`;
                  if (prItemId)    await github.graphql(setM, { projectId, itemId: prItemId,    fieldId: statusField.id, optId: opt.id });
                  if (issueItemId) await github.graphql(setM, { projectId, itemId: issueItemId, fieldId: statusField.id, optId: opt.id });
                }
              }

              // Start date (빈 경우에만 세팅, YYYY-MM-DD)
              const startFieldName = "Start date";
              const startDate = (pr.created_at || new Date().toISOString()).substring(0,10);

              const getDateFieldValue = async (itemId, fieldName) => {
                if (!itemId) return null;
                const q = `
                  query($itemId:ID!) {
                    node(id:$itemId) {
                      ... on ProjectV2Item {
                        fieldValues(first:50) {
                          nodes {
                            ... on ProjectV2ItemFieldDateValue {
                              date
                              field { ... on ProjectV2FieldCommon { id name } }
                            }
                          }
                        }
                      }
                    }
                  }`;
                const r = await github.graphql(q, { itemId });
                const nodes = r?.node?.fieldValues?.nodes || [];
                const hit = nodes.find(n => n?.field?.name === fieldName);
                return hit?.date || null;
              };

              const fieldsQ2 = `
                query($projectId:ID!) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      fields(first:50) { nodes { ... on ProjectV2FieldCommon { id name dataType } } }
                    }
                  }
                }`;
              const fr2 = await github.graphql(fieldsQ2, { projectId });
              const fields2 = fr2?.node?.fields?.nodes || [];
              const startField = fields2.find(f => f.name === startFieldName && f.dataType === "DATE");
              const startFieldId = startField?.id || null;

              const setDateM = `
                mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $d:Date!) {
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                    value:{ date:$d }
                  }) { projectV2Item { id } }
                }`;

              const setStartIfEmpty = async (itemId) => {
                if (!itemId || !startFieldId) return;
                const existing = await getDateFieldValue(itemId, startFieldName);
                if (existing) return;
                await github.graphql(setDateM, { projectId, itemId, fieldId: startFieldId, d: startDate });
              };

              await setStartIfEmpty(prItemId);
              await setStartIfEmpty(issueItemId);
            } catch (e) {
              core.warning(`Project ensure failed: ${e?.message || e}`);
            }
